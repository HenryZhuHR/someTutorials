# 目录
- [目录](#目录)
- [类的定义和对象的创建](#类的定义和对象的创建)
- [继承](#继承)
- [多态](#多态)
- [访问控制](#访问控制)
  - [const访问控制](#const访问控制)
    - [常量成员函数](#常量成员函数)
- [接口](#接口)
  - [接口特征](#接口特征)
  - [接口文件结构](#接口文件结构)

# 类的定义和对象的创建
```cpp

```
# 继承
# 多态


# 访问控制
## const访问控制

### 常量成员函数


# 接口
[参考教程](https://blog.csdn.net/netyeaxi/article/details/80887646)

## 接口特征
而对于C++，其接口类一般具有以下特征：

- 最好不要有成员变量，但可以有静态常量（static const或enum）
> 如果成员变量，尤其是可变的成员变量，定义在接口中，等于是把实现细节暴露出来了，不符合接口定义的要求，所以一般不在接口中定义可变的成员变量。
而常量可以定义在接口中，因为有时接口需要返回状态，而这些状态可以定义成常量放在接口中。

- 要有纯虚接口方法
> 由于不能让接口类自身能够实例化，并且需要子类必须实现接口暴露的方法，所以接口方法都要声明成纯虚函数。
声明成纯虚函数意味着接口类自身不需要提供方法的定义，方法的定义需要由接口类的子类提供，并且接口类自身也因此变成了抽象类而不能被实例化。

- 要有虚析构函数，并提供默认实现
> a). 在使用接口类的指针访问接口类的子类的实例时，当对接口类的指针做delete时，如果接口类的析构函数不是虚析构函数的话，将只会调用接口类的析构函数，接口类的子类的析构函数将不会被调用，内存泄露将会产生，所以接口类的析构函数必须定义成虚析构函数。
> 
> b). 如果接口类的析构函数不提供默认实现，即如果接口类的析构函数是纯虚析构函数的话，接口类的子类将被迫必须提供析构函数的实现，这样对接口类的子类不友好。
> 
> c). 在C++11中也可以用：  virtual ~Testable() = default; 替代 virtual ~Testable() {};


- 不要声明构造函数
> 不要显式定义任何的构造函数，但也不要在接口中加入如下代码来禁止生成构造函数：
```cpp
Testable() = delete;
Testable(const Testable&) = delete;
```
因为C++的调用机制要求子类的构造函数调用时一定会先调用父类的构造函数，如果禁止生成构造函数，代码编译时会报错。如果程序员不显式的提供构造函数，编译器也会隐式的加上构造函数的，虽然这些构造函数对于接口类来说实际没有什么意义。


## 接口文件结构
接口类头文件
```cpp
#include "<ClassName>.h"
```
接口实现类头文件
```cpp
#include "<ClassName>_impl.h"
```
> impl : 实现类; 接口实现;

文件结构
```bash
proj-+
     |-inc-+
     |     |-<ClassName>.h
     |     |-<ClassName>_manager.h
     |
     |-src-+
           |-<ClassName>_impl.h
           |-<ClassName>_impl.cpp
           |-<ClassName>_manager.cpp
```


